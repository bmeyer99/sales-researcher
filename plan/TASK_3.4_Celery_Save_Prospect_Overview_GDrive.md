# Task 3.4: Celery Task - Save Prospect Overview to GDrive

**Phase:** Phase 3: Core Research Logic - Gemini API & Celery Tasks
**Parent Plan:** [PROJECT_PLAN.md](PROJECT_PLAN.md)
**Status:** To Do
**Last Updated:** 2025-05-29

## 1. Description
This task (or a part of a larger Celery task chain) takes the company overview text generated by the "Prospect Deep Dive" (Task 3.3) and saves it as a text or Markdown file to the user's specified Google Drive folder.

## 2. Detailed Steps / Implementation Notes

1.  **Integration with `prospect_deep_dive_task` or as a Chained Task:**
    *   **Option A (Part of `prospect_deep_dive_task`):** The logic for saving can be directly added at the end of `prospect_deep_dive_task` after the overview text is parsed.
    *   **Option B (Separate Chained Task):** `prospect_deep_dive_task` returns the `overview_text` and `drive_folder_id`. A new Celery task, say `save_text_to_gdrive_task`, is then called with this data. This promotes better separation of concerns. For this plan, we'll assume it can be a separate, chainable task or a clear step within the main research workflow.

2.  **Define Celery Task (if separate - `save_text_to_gdrive_task`):**
    *   If a separate task, define it in a relevant module (e.g., `backend/tasks/google_drive_tasks.py` or keep it in `gemini_research.py` if closely related).
    *   The task would accept `content: str`, `file_name: str`, and `drive_folder_id: str`.
        ```python
        # Example if a separate task in backend/tasks/google_drive_tasks.py
        from backend.celery_app import celery_app
        from backend.services.google_drive_service import upload_text_file # Assumes this service exists from Task 2.3
        # from ..services.google_drive_service import get_drive_service, upload_text_file # Relative import if structured

        @celery_app.task(name="save_text_to_gdrive_task")
        def save_text_to_gdrive_task(file_content: str, file_name: str, drive_folder_id: str, company_name: str):
            """
            Saves the given text content to a file in Google Drive.
            """
            # Placeholder for status updates
            # update_task_status(self.request.id, f"Saving '{file_name}' to Google Drive for {company_name}", 1, 1)
            print(f"Attempting to save '{file_name}' to GDrive folder ID: {drive_folder_id} for {company_name}")

            try:
                # User's Google credentials (access token) need to be available to `upload_text_file`.
                # This is a simplification. In a real Celery task, you wouldn't pass raw tokens.
                # Instead, the `upload_text_file` service method would need to be able
                # to retrieve the user's current, valid credentials, possibly using a user_id
                # passed to the task to look up stored refresh tokens and generate an access token.
                # This is a CRITICAL part of the design for Celery tasks interacting with user-specific APIs.
                # For now, we assume `upload_text_file` handles auth internally based on context or passed user_id.
                
                # This implies `upload_text_file` needs to be adapted or called in a context where
                # user-specific credentials for Google Drive API are available.
                # This might involve passing a user_id to this task, then using that user_id
                # to fetch the necessary Google OAuth tokens (managed by Phase 1 logic)
                # before calling the actual Google Drive upload.

                # For the purpose of this task's plan, we assume `upload_text_file` can be called.
                # The actual mechanism of providing credentials to it from a Celery task is a deeper implementation detail.
                
                upload_result = upload_text_file(
                    file_name=file_name,
                    file_content=file_content,
                    folder_id=drive_folder_id,
                    mime_type='text/markdown' # Or 'text/plain'
                )
                # update_task_status(self.request.id, f"Successfully saved '{file_name}'", 1, 1)
                print(f"Successfully saved '{file_name}' to GDrive. File ID: {upload_result.get('id')}")
                return {
                    "status": "success",
                    "file_id": upload_result.get('id'),
                    "file_name": file_name,
                    "drive_folder_id": drive_folder_id,
                    "webViewLink": upload_result.get('webViewLink')
                }
            except Exception as e:
                # update_task_status(self.request.id, f"Error saving '{file_name}': {e}", 1, 1)
                print(f"Error saving '{file_name}' to GDrive: {e}")
                # Handle error: raise an exception for Celery to retry or mark as failed
                raise
        ```

3.  **Call the Upload Function:**
    *   Use the `upload_text_file` function/method from `GoogleDriveService` (Task 2.3).
    *   **File Naming:** Construct a descriptive filename, e.g., `"{company_name}_Prospect_Overview.md"`.
    *   **Content:** Pass the `overview_text` obtained from Task 3.3.
    *   **Folder ID:** Pass the `drive_folder_id` that was initially provided or determined.

4.  **Credential Management in Celery Tasks (CRITICAL):**
    *   Celery tasks run asynchronously and potentially on different machines, separate from the user's initial web request context.
    *   **They cannot directly use session-based OAuth tokens from the web request.**
    *   **Solution:**
        *   When the Celery task is initiated, pass a `user_id` (or another secure identifier for the user).
        *   The Celery task (or a service it calls, like `upload_text_file`) must use this `user_id` to:
            1.  Retrieve the user's securely stored Google OAuth refresh token (stored during Task 1.2).
            2.  Use the refresh token to obtain a fresh, short-lived access token (as per Task 1.5 logic).
            3.  Use this fresh access token to initialize the Google Drive API client for the upload.
    *   This means the `GoogleDriveService.upload_text_file` (or the way it gets its `drive_service` client) needs to be aware of this user context or be callable with user-specific credentials.

5.  **Error Handling:**
    *   Handle errors from the file upload process (e.g., GDrive API errors, permission issues).
    *   The Celery task should report success or failure.

## 3. Expected Output / Deliverables
*   The company overview text (generated in Task 3.3) is successfully saved as a file (e.g., Markdown) in the specified Google Drive folder.
*   The Celery task (or the relevant part of the main task) completes and reports the status of the file upload (e.g., success with file ID/link, or failure with error).

## 4. Dependencies
*   Task 2.3: Backend - File Upload Functionality (provides the `upload_text_file` method).
*   Task 3.3: Celery Task - Prospect Deep Dive (provides `overview_text`, `company_name`, `drive_folder_id`).
*   A robust mechanism for Celery tasks to obtain/use user-specific Google OAuth access tokens (relying on stored refresh tokens and refresh logic from Task 1.5).

## 5. Acceptance Criteria
*   After the `prospect_deep_dive_task` (and this saving step) completes, the overview report file exists in the correct Google Drive folder.
*   The file content matches the overview text generated by Gemini.
*   The filename is as expected.
*   Failures during the GDrive upload are handled and logged by the Celery task.

## 6. Estimated Effort (Optional)
*   Medium (primarily due to the complexity of handling user-specific credentials securely within asynchronous Celery tasks).

## 7. Notes / Questions
*   **Security of Credentials in Tasks:** This is the most critical aspect. Never pass raw access/refresh tokens directly to Celery task arguments if they can be logged or exposed. Pass user identifiers and have the task securely retrieve/generate tokens.
*   **Task Granularity:** Decide if this is a separate task or a step in `prospect_deep_dive_task`. Separate tasks can be good for retrying specific failed steps but add a bit more orchestration.
*   **Status Reporting:** How this task reports its progress/completion back to the main process or UI needs to be considered (will be covered more in Phase 5).